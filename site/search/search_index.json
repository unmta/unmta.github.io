{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Warning</p> <p>UnMTA is in pre-alpha. Expect frequent breaking changes.</p> <p>TODO</p>"},{"location":"configuration/","title":"Configuration","text":"<p>UnMTA works out of the box without any configuration parameters. However, to adapt the server to your specific environment, there are number of parameters we can set via the cleverly named <code>unfig.toml</code> file. </p> <p>Let's start by creating a <code>config</code> directory, and adding a default <code>unfig.toml</code> file to it:</p> <pre><code>mkdir config\ntouch config/unfig.toml\n</code></pre> config/unfig.toml<pre><code># Below are all the configuration options, along with their default values\n[smtp]\nport=2525\nlisten=\"localhost\" # Use 0.0.0.0 to listen on all interfaces\n#hostname=\"your.mail.server\" # Optional, defaults to the hostname of the machine\ninactivityTimeout=300 # Seconds to wait before closing an idle connection\ngracefulStopTimeout=300 # Seconds to wait before forcing the server to shut down after a stop() is issued\n\n[auth]\nenable=false # Enable SMTP authentication\nrequireTLS=true # Require TLS before authentication\n\n[tls]\nenableStartTLS=false # Enable STARTTLS Support\n#key=\"tls_key.pem\" # Path to the TLS key file\n#cert=\"tls_cert.pem\" # Path to the TLS certificate file\n\n[log]\nlevel = \"smtp\" # error, warn, info, debug, smtp\n\n[plugins]\n# Plugin specific configs. Example:\n# [plugins.examplePlugin]\n# doStuff=true\n</code></pre> <p>Note</p> <p>The <code>config</code> directory will also house the configuration files for your plugins.</p>"},{"location":"deploying-to-production/","title":"Deploying to Production","text":"<p>TODO</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites:","text":"<ul> <li>Make sure you have Node.js &gt;= v20 installed</li> <li>To run the examples, you may want to have tsx installed: <code>npm install -g tsx</code></li> </ul> <p>Let\u2019s start by creating a workspace for the UnMTA Smtp Server:</p> <pre><code>mkdir unmta-smtp-server-project\ncd unmta-smtp-server-project\nnpm init\n# Follow the `npm init` prompts\n</code></pre> <p>Now we can install UnMTA Smtp Server:</p> <pre><code>npm i @unmta/smtp-server\n</code></pre> <p>Now let\u2019s create an index.ts or index.js file to bootstrap the server. Feel free to use either TypeScript or JavaScript. We\u2019ll be using TypeScript in our examples.</p> index.ts<pre><code>import { SmtpServer } from \"@unmta/smtp-server\";\n\nconst server = new SmtpServer();\nserver.start();\n</code></pre> <p>Now we\u2019re ready to start the server. By default, the server will bind to your localhost interface on port 2525:</p> <pre><code>tsx index.ts\n</code></pre> <pre><code>[info]: Unfig (config) loaded\n[info]: Logger initialized. Level: 'smtp'\n[info]: UnMTA SMTP server is running on localhost:2525\n</code></pre> <p>Congratulations! You\u2019re running the UnMTA SMTP Server. What can it do at this point? Absolutely nothing. Let\u2019s fix that by learning about the Configuration Options and Writing Plugins</p>"},{"location":"writing-plugins/","title":"Writing Plugins","text":""},{"location":"writing-plugins/#plugins-overview","title":"Plugins Overview","text":"<p>Plugins are the core component UnMTA. Without them, the server can\u2019t do anything besides reject mail.</p> <p>Plugins bind to one or more server events, called Hooks. A plugin can read and modify Session data to guide its behavior. After performing its designated function, a plugin can either trigger a Response to the client or allow the server to continue processing other plugins and hooks.</p> <p>Writing plugins for UnMTA is designed to be quick and easy. Let\u2019s take a look at a basic example. This plugin binds to the <code>onRcptTo</code> hook and will accept <code>peter.gibbons@initech.com</code>, defer <code>milton.waddams@initech.com</code>, and reject all others.</p> <p>Let\u2019s create a <code>plugins</code> directory, if we haven\u2019t already, and add a file called <code>examplePlugin.ts</code>.</p> <pre><code>mkdir plugins\ntouch plugins/examplePlugin.ts\n</code></pre> plugins/examplePlugin.ts<pre><code>import { SmtpPlugin, SmtpResponse } from '@unmta/smtp-server';\n\nexport const examplePlugin: SmtpPlugin = {\n  pluginName: 'examplePlugin',\n  onRcptTo: (session, recipient, command) =&gt; {\n    if (recipient.address === 'peter.gibbons@initech.com') {\n      return SmtpResponse.RcptTo.accept();\n    } else if (recipient.address === 'milton.waddams@initech.com') {\n      return SmtpResponse.RcptTo.defer(421, \"Yeah, we can't actually find a record of him being a current employee here\");\n    }\n    return SmtpResponse.RcptTo.reject();\n  },\n};\n</code></pre> <p>Note</p> <p>A unique <code>pluginName</code> property is required as it allows the plugin to store session data within its own namespace and allows other plugins to access that session data.</p> <p>We can now add this plugin to our SMTP Server like so:</p> index.ts<pre><code>import { SmtpServer, smtpPluginManager } from '@unmta/smtp-server';\nimport { examplePlugin } from './plugins/examplePlugin';\n\nsmtpPluginManager.loadPlugins([examplePlugin]);\nconst server = new SmtpServer();\nserver.start();\n</code></pre> <p>That\u2019s it. The server will now apply the <code>examplePlugin</code>\u2019s logic to the <code>onRcptTo</code> hook.</p> <p>Note</p> <ul> <li>Plugins will be called in the order they\u2019re loaded via the <code>loadPlugins</code> method.</li> <li>A plugin can contain one or many event hooks</li> </ul> <p>A plugin can be a mere observer, or it can take near complete control of the server. Within a plugin, you can access data from a database, store session data, pass messages to other plugins, determine the server\u2019s responses, and more. To learn how to make the most of plugins, let\u2019s dig into the remaining fundamentals.</p>"},{"location":"writing-plugins/#configuration","title":"Configuration","text":"<p>Plugins have read access to all server and plugin configuration parameters as defined in the default Configuration File. Additionally, you can define plugin-specific parameters in one of two ways:</p> <ol> <li>Add to the <code>[plugins]</code> section in the <code>unfig.toml</code> file:</li> </ol> config/unfig.toml<pre><code>[plugins]\n\n[plugins.examplePlugin]\ndoStuff=true\n</code></pre> <ol> <li>Create a new TOML configuration file in the <code>config/</code> directory using the <code>pluginName</code> of your plugin:</li> </ol> config/examplePlugin.toml<pre><code>doStuff=true\n</code></pre> <p>Note</p> <p>Parameters set in an external config file (Ex: <code>config/yourPluginName.toml</code>) take precedence over parameters set in the <code>config/unfig.toml</code> file (Ex: <code>[plugins.yourPluginName]</code>).</p>"},{"location":"writing-plugins/#reading-configuration-data","title":"Reading Configuration Data","text":"<pre><code>import { unfig } from '@unmta/smtp-server';\nexport const examplePlugin: SmtpPlugin = {\n  // ...\n  onConnect: async (session) =&gt; {\n    const authEnabled = unfig.auth.enable;\n    const doStuff = unfig.plugins.examplePlugin.doStuff;\n    // ...\n  },\n  // ...\n};\n</code></pre> <p>Warning</p> <p>All configuration parameters are readonly</p>"},{"location":"writing-plugins/#sessions","title":"Sessions","text":"<p>Session data is a per-connection store of information set by the server, other plugins, and your plugins. Plugins have read access to session data set by the server and by other plugins, and read/write access to its own session data. Let's take a look at the server-level session data.</p>"},{"location":"writing-plugins/#server-session-data","title":"Server Session Data","text":"Property Type Description id <code>number</code> A unique identifier for the session activeConnections <code>number</code> Total number of active connections startTime <code>number</code> The time the session started (<code>Date.now()</code>) remoteAddress <code>string</code> The remote IP address of the client phase <code>string</code> The current phase of the SMTP session greetingType <code>string</code> or <code>null</code> The greeting type used by the client (<code>HELO</code> or <code>EHLO</code>) isSecure <code>boolean</code> Whether the connection is secured via TLS or STARTTLS isAuthenticated <code>boolean</code> Whether the client has authenticated successfully isDataMode <code>boolean</code> Whether the session is currently receiving data in <code>DATA</code> mode dataStream <code>PassThrough</code> or <code>null</code> Incoming message data stream sender <code>EnvelopeAddress</code> or <code>null</code> The sender specified via <code>MAIL FROM</code> recipients <code>EnvelopeAddress[]</code> The recipient(s) specified during <code>RCPT TO</code>"},{"location":"writing-plugins/#session-phases","title":"Session Phases","text":"<p>The session <code>phase</code> is primarily used by the server to ensure things are happening in their proper order. However, it can be useful for some plugins to know where they are in a transaction when, say, an <code>RSET</code> command is issued.</p> Phase Description connection Initial connection before any commands auth Authentication phase helo <code>HELO</code>/<code>EHLO</code> command sender <code>MAIL FROM</code> command recipient <code>RCPT TO</code> command data After <code>DATA</code> command and during data reception postdata After data reception has completed"},{"location":"writing-plugins/#reading-server-session-data","title":"Reading Server Session Data","text":"<p>Accessing the session data from within a plugin is as simple as referencing the property directly from the <code>session</code> object:</p> <pre><code>const examplePlugin: SmtpPlugin = {\n  pluginName: 'examplePlugin',\n  onConnect: (session) =&gt; {\n    console.log(session.id); // Ex: 123\n  },\n};\n</code></pre> <p>Warning</p> <p>Server session properties are readonly</p>"},{"location":"writing-plugins/#plugin-session-data","title":"Plugin Session Data","text":"<p>Plugins can read/write to their own namespace (as denoted by their <code>pluginName</code> property). Additionally, plugins may read from other plugins session data using their respective <code>pluginName</code>.</p> <pre><code>const examplePlugin: SmtpPlugin = {\n  pluginName: 'examplePlugin',\n  onConnect: (session) =&gt; {\n    session.setOwnPluginData('key', 'value'); // Sets session data in the examplePlugin namespace\n    session.getOwnPluginData('key'); // Returns: 'value'\n    session.getPluginData('anotherPluginName', 'key'); // Returns value for 'key' parameter from an external plugin, if set\n  },\n};\n</code></pre>"},{"location":"writing-plugins/#global-context","title":"Global Context","text":"<p>Many plugins will also have the need to reference data that transcends the life of a given connection. For example, your plugin may want establish a database connection. That's where the global SMTP Context fits in.</p> <pre><code>export const examplePlugin: SmtpPlugin = {\n  // ...\n  onServerStart: async () =&gt; {\n    const db = await initDatabase();\n    // Store the db connection when the server starts\n    SmtpContext.getInstance().set('exampleDBConnection', db);\n  },\n  onConnect: async (session) =&gt; {\n    // Access the db connection anywhere it's needed\n    const db = SmtpContext.getInstance().get('exampleDBConnection');\n    // ...\n  },\n  // ...\n};\n</code></pre> <p>Once set, the context value remains until the server is stopped or the value is overwritten.</p> <p>Warning</p> <p>Global values are, well, global. Use descriptive names to ensure you don't overwrite values set by 3rd party plugins.</p>"},{"location":"writing-plugins/#hooks","title":"Hooks","text":"<p>UnMTA exposes two types of hooks: SMTP Hooks for SMTP transactions, and Server Hooks for server events. Let\u2019s start with SMTP Hooks:</p>"},{"location":"writing-plugins/#smtp-hooks","title":"SMTP Hooks","text":"<p>SMTP Hooks are events triggered during an SMTP session. UnMTA allows you to attach to virtually every event in an SMTP transaction to shape the outcome of that event.</p> <p>Note</p> <p>Hooks may be called multiple times per session if the client issues a <code>RSET</code> or another <code>HELO</code>/<code>EHLO</code> command. In some cases, your code may need to account for this fact.</p> Hook Parameters Description onConnect <code>session</code> Called when a connection is first established with a client. onHelo <code>session</code>, <code>hostname</code>, <code>verb</code> Called after <code>HELO</code> / <code>EHLO</code> command. <code>verb</code> specifies which command was used. onAuth <code>session</code>, <code>username</code>, <code>password</code> Called after <code>AUTH</code> command once <code>username</code> and <code>password</code> have been provided from the client. onMailFrom <code>session</code>, <code>address</code>, <code>command</code> Called after <code>MAIL FROM</code>. Includes <code>EmailAddress</code> object and full <code>SmtpCommand</code>. onRcptTo <code>session</code>, <code>address</code>, <code>command</code> Called after <code>RCPT TO</code>. Includes <code>EmailAddress</code> object and full <code>SmtpCommand</code>. onDataStart <code>session</code> Called after the DATA command. onDataEnd <code>session</code> Called after the entire message has been received from the client. onQuit <code>session</code> Called after the <code>QUIT</code> command just before the connection is closed. onClose <code>session</code> Called after the connection has been closed. Cannot return a response. onRset <code>session</code> Called after the <code>RSET</code> command, before the server resets the session data. onHelp <code>session</code> Called after the <code>HELP</code> command. onNoop <code>session</code> Called after the <code>NOOP</code> command. onVrfy <code>session</code>, <code>command</code> Called after the <code>VRFY</code> command. Includes full <code>SmtpCommand</code>. onUnknown <code>session</code>, <code>command</code> Called after an unknown command. Includes full <code>SmtpCommand</code>."},{"location":"writing-plugins/#server-hooks","title":"Server Hooks","text":"<p>There are two additional hooks that relate to the server itself: <code>onServerStart</code>, and <code>onServerStop</code>. Unlike SMTP Hooks, they accept no parameters and can return no values. The <code>onServerStart</code> hook can be used to establish database connections, etc, while the <code>onServerStop</code> hook may be used to close database connections and perform cleanup tasks when the server is shutdown.</p>"},{"location":"writing-plugins/#responses","title":"Responses","text":"<p>All SMTP Hooks, except <code>onClose</code>, can optionally return an <code>accept</code>, <code>defer</code>, or <code>reject</code> response. If a plugin returns a response, the server will skip any other plugins for that hook during the given connection. By not returning any value, the plugin allows the server to continue calling other plugins for the current hook.</p> <p>Tip</p> <p>Choosing the correct response code and message can be challenging. Certain responses are not permissible depending on the phase of the SMTP session. UnMTA has created \"guardrail\" response classes that make it easy to say the right thing at the right time.</p> <pre><code>onConnect: async (session) =&gt; {\n    doStuff();\n    // No response returned. Other onConnect plugins will be called\n  },\nexport const examplePlugin: SmtpPlugin = {\n  onHelo: (session) =&gt; {\n    // Don't call any other plugins, just send an accept response\n    return SmtpResponse.Helo.accept();\n  },\n  onAuth: (session, username, password) =&gt; {\n    // Don't call any other plugins, send a custom reject response\n    return SmtpResponse.Auth.reject(535, '5.7.8 YOU SHALL NOT PASS!');\n  },\n};\n</code></pre> <p>Note how each hook has a corresponding SMTP response type (<code>SmtpResponse.Helo</code> for <code>HELO</code>/<code>EHLO</code>, <code>SmtpResponse.Auth</code> for <code>AUTH</code>, etc). These response types provide a default way to either <code>accept</code> (send a <code>2XX</code> or <code>3XX</code> response), defer (send a <code>4XX</code> response), or reject (send a <code>5XX</code> response).</p> <p>By simply calling a relevant <code>accept()</code>, <code>defer()</code>, or <code>reject()</code>, the server will issue a standard RFC-compliant response. If you want to send a non-default (but still RFC-compliant) status code, you can specify that as the first parameter in an accept/defer/reject method. And, if you'd like to add a custom message, you can specify that as the second parameter.</p> <p>Tip</p> <p>The easiest way to see all of the available response codes and messages is to look at the SmtpResponse Class</p> <p>While it's recommended to rely on the guardrail response classes to ensure you stay RFC compliant, if you wish to respond with a status code and/or message that the guardrail classes don't permit, there's <code>SmtpResponseAny</code>:</p> <pre><code>export const examplePlugin: SmtpPlugin = {\n  onHelo: (session) =&gt; {\n    // Return a non-standard response. Because reasons.\n    return SmtpResponseAny(469, '4.2.0 I believe you have my stapler');\n  },\n};\n</code></pre> <p>Note</p> <ul> <li>Certain responses (example, a defer response that returns a 421) will also close the connection.</li> </ul>"},{"location":"writing-plugins/#logging","title":"Logging","text":"<p>Plugins can piggy-back on UnMTA's logger:</p> <pre><code>import { logger } from '@unmta/smtp-server';\nexport const examplePlugin: SmtpPlugin = {\n  onHelo: (session) =&gt; {\n    logger.debug('oh hai, mark');\n  },\n};\n</code></pre> <p>The logger supports the following log levels:</p> Level Method Details 0 error Uncaught exceptions and other unrecoverable issues 1 warn Potential problems that may not currently affect the system\u2019s operation but could lead to future issues 2 info General operational messages that describe normal functioning 3 debug Typically used during development or troubleshooting 4 smtp Displays full SMTP client&lt;-&gt;server chatter <p>To setup log rotation and other advanced logging features, see Deploying to Production</p>"},{"location":"writing-plugins/#writing-public-plugins","title":"Writing Public Plugins","text":"<p>Tip</p> <p>UnMTA welcomes 3rd party contributions!</p> <p>First, let\u2019s discuss the philosophy behind writing public plugins for use with UnMTA. Your plugin should be designed to \u201cdo the thing\u201d it\u2019s supposed to do, and nothing more. If you\u2019re writing a plugin to scan for viruses, your plugin should, for example, scan for viruses and store the results in the session, and that\u2019s all. This enables your end-users to write simple downstream plugins to handle those results however they prefer.</p>"},{"location":"writing-plugins/#a-good-plugin-example","title":"A good plugin example","text":"<pre><code>onDataEnd: async (session) =&gt; {\n  const result = await doVirusScan();\n  session.setOwnPluginData('result', result);\n  // This will allow downstream plugins to decide how to handle the message.\n},\n</code></pre>"},{"location":"writing-plugins/#a-bad-plugin-example","title":"A bad plugin example","text":"<p>Many MTAs have plugins that try and do everything. Taking the virus scan example, these plugins often offer up configuration parameters on whether or not to reject the message, add a prefix to the subject line, add an X-Header, etc. The result is a far more complicated plugin than what is really needed and there will be an endless supply of use-cases that your plugin doesn\u2019t quite fit.</p> <pre><code>onDataEnd: (session) =&gt; {\n  const result = await doVirusScan();\n  if (result.hasVirus) {\n    if (unfig.plugins.virusPlugin.rejectInfectedEmails) {\n      return SmtpResponse.Data.reject(550, 'Message contains a virus');\n    } else if (unfig.plugins.virusPlugin.tagInfectedEmails) {\n      return SmtpResponse.Data.accept(250, 'Message accepted for delivery (virus detected)');\n    } else if (unfig.plugins.virusPlugin.quarantineInfectedEmails) {\n      return SmtpResponse.Data.accept(250, 'Message quarantined (virus detected)');\n    } else if (unfig.plugins.virusPlugin.deleteInfectedEmails) {\n      return SmtpResponse.Data.accept(250, 'Message deleted (virus detected)');\n    } else if (unfig.plugins.virusPlugin.deferInfectedEmails) {\n      return SmtpResponse.Data.defer(450, 'Message deferred (virus detected)');\n    }\n    // ... and on\n    // ... and on\n    // ... and on it goes\n  }\n};\n</code></pre> <p>See the difference? Let\u2019s keep the Simple in SMTP.</p>"}]}